<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Client ↔ Stripe Matcher</title>
  <style>
    :root {
      --bg: #0b1220;
      --muted: #19223a;
      --card: #0f172a;
      --accent: #4f46e5;
      --accent-2: #22c55e;
      --text: #e5e7eb;
      --subtle: #94a3b8;
      --warn: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(180deg, var(--bg), #0a0f1a 65%);
      color: var(--text);
    }
    header {
      padding: 28px 20px 10px; text-align: center; position: sticky; top: 0; backdrop-filter: blur(8px); background: linear-gradient(180deg, rgba(11,18,32,.9), rgba(11,18,32,.6)); z-index: 40; border-bottom: 1px solid #1f2937;
    }
    h1 { font-size: 22px; margin: 0 0 6px; letter-spacing: .2px; }
    .subtitle { color: var(--subtle); font-size: 13px; }
    main { max-width: 1200px; margin: 20px auto 80px; padding: 0 16px; }

    .grid { display: grid; gap: 14px; }
    @media (min-width: 920px) { .grid-3 { grid-template-columns: repeat(3, 1fr);} }
    @media (max-width: 919px) { .grid-3 { grid-template-columns: 1fr; } }

    .card { background: var(--card); border: 1px solid #1f2937; border-radius: 14px; padding: 16px; box-shadow: 0 8px 30px rgba(0,0,0,.25); }
    .card h2 { font-size: 16px; margin: 0 0 8px; }
    .card h3 { font-size: 14px; margin: 0 0 8px; color: var(--subtle); font-weight: 600; }

    .hint { color: var(--subtle); font-size: 12px; }
    .row { display:flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row > * { flex: 1; }

    .filebox { border: 1px dashed #334155; padding: 10px; border-radius: 10px; background: #0b1220; }
    input[type="file"] { width: 100%; padding: 8px; color: var(--subtle); }

    select, input[type="text"], input[type="number"], input[type="checkbox"] {
      background: #0b1220; border: 1px solid #334155; color: var(--text); padding: 8px 10px; border-radius: 10px; width: 100%; outline: none;
    }
    label { font-size: 12px; color: var(--subtle); display:block; margin: 6px 0 4px; }

    .btn { background: var(--accent); color: white; border: none; padding: 10px 14px; border-radius: 12px; font-weight: 600; cursor: pointer; transition: transform .04s ease, opacity .2s; }
    .btn:hover { transform: translateY(-1px); }
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    .btn-outline { background: transparent; border: 1px solid #334155; }
    .btn-ghost { background: transparent; color: var(--text); }
    .btn-success { background: var(--accent-2); }
    .btn-warn { background: var(--warn); color: #111827; }

    .pill { display:inline-flex; gap:6px; align-items:center; padding: 2px 8px; border-radius: 999px; font-size: 11px; border: 1px solid #334155; background:#0b1220; color: var(--subtle); }
    .pill.new { border-color: #2563eb; color:#bfdbfe; }
    .pill.multi { border-color: #22c55e; color:#bbf7d0; }

    .tabbar { display:flex; gap: 8px; flex-wrap: wrap; margin: 12px 0; }
    .tabbar button { background: #0b1220; border: 1px solid #334155; color: var(--subtle); padding: 8px 12px; border-radius: 10px; cursor:pointer; }
    .tabbar button.active { background: var(--accent); color: white; border-color: transparent; }

    details summary { cursor: pointer; user-select: none; }
    details { border: 1px solid #1f2937; border-radius: 12px; padding: 10px 12px; background: #0b1220; }
    details + details { margin-top: 8px; }
    details .summary-row { display:flex; justify-content: space-between; align-items:center; gap: 8px; }

    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { text-align: left; padding: 8px 10px; border-bottom: 1px solid #1f2937; font-size: 13px; }
    th { color: var(--subtle); font-weight: 600; }

    .right { text-align: right; }

    .footer { color: var(--subtle); font-size: 12px; text-align:center; margin-top: 18px; }

    .spacer { height: 10px; }

    .tag { display:inline-block; font-size:11px; padding: 2px 6px; border-radius: 6px; background: #111827; border: 1px solid #334155; color: #e5e7eb; }
    .tag.fb { background:#0b1322; border-color:#1e40af; }
    .tag.tt { background:#08131a; border-color:#0ea5e9; }
    .tag.yt { background:#1a0b0b; border-color:#b91c1c; }
    .tag.smm { background:#10111a; border-color:#7c3aed; }
    .tag.csm { background:#0e1a12; border-color:#16a34a; }

    .badge { display:inline-flex; align-items:center; gap:6px; font-size: 11px; padding: 2px 6px; border-radius: 999px; border:1px solid #334155; color:#cbd5e1; }

    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0a0f1a; border:1px solid #334155; border-bottom-width:2px; padding: 2px 6px; border-radius:6px; font-size:12px; }
  </style>
</head>
<body>
  <header>
    <h1>Client ↔ Stripe Matcher</h1>
    <div class="subtitle">Upload CSVs → Map columns → Match by <span class="kbd">Customer ID</span>, <span class="kbd">Email</span>, or <span class="kbd">Name</span> → Summaries per person & platform. <strong>CSM is a manager team (not a platform).</strong></div>
  </header>

  <main>
    <div class="grid grid-3">
      <section class="card">
        <h2>1) Upload CSVs</h2>
        <div class="grid">
          <div class="filebox">
            <label>CSV 1 — Main Client List (from Monday.com)</label>
            <input type="file" id="file-main" accept=".csv" />
            <div class="hint" id="hint-main">No file chosen.</div>
          </div>
          <div class="filebox">
            <label>CSV 2 — Onboarding (New Clients, from Monday.com)</label>
            <input type="file" id="file-onboard" accept=".csv" />
            <div class="hint" id="hint-onboard">No file chosen.</div>
          </div>
          <div class="filebox">
            <label>CSV 3 — Stripe (payments or subscriptions)</label>
            <input type="file" id="file-stripe" accept=".csv" />
            <div class="hint" id="hint-stripe">No file chosen.</div>
          </div>
        </div>
        <div class="spacer"></div>
        <div class="row">
          <div>
            <label>Currency Symbol</label>
            <input type="text" id="currency-symbol" value="$" />
          </div>
          <div>
            <label>Fuzzy Name Match</label>
            <select id="fuzzy-mode">
              <option value="off">Off (exact/normalized)</option>
              <option value="loose">Loose</option>
              <option value="aggressive">Aggressive</option>
            </select>
          </div>
          <div>
            <label>Lowercase Emails When Matching</label>
            <select id="email-normalize">
              <option value="yes">Yes</option>
              <option value="no">No</option>
            </select>
          </div>
        </div>
      </section>

      <section class="card">
        <h2>2) Map Columns</h2>
        <div class="hint">After uploading, pick which columns correspond to each field. Per-team columns can contain multiple names (comma/semicolon/"and").</div>

        <div id="mapping-main"></div>
        <div id="mapping-onboard" style="margin-top:12px"></div>
        <div id="mapping-stripe" style="margin-top:12px"></div>
      </section>

      <section class="card">
        <h2>3) Run Matching</h2>
        <div class="row" style="align-items:flex-end">
          <div>
            <label for="btn-run">Ready?</label>
            <button id="btn-run" class="btn" disabled>Match & Summarize</button>
          </div>
          <div>
            <label>Export</label>
            <div class="row">
              <button id="btn-export-person" class="btn btn-outline" disabled>By Person (CSV)</button>
              <button id="btn-export-platform" class="btn btn-outline" disabled>By Platform (CSV)</button>
              <button id="btn-export-unmatched" class="btn btn-outline" disabled>Unmatched (CSV)</button>
            </div>
          </div>
        </div>
        <div id="run-stats" class="hint" style="margin-top:8px"></div>
        <div class="hint" style="margin-top:6px"><strong>Note:</strong> Platform totals include Facebook, TikTok, YouTube, and SMM (Posts). CSM appears only under people, not platforms.</div>
      </section>
    </div>

    <section class="card" style="margin-top:14px">
      <div class="tabbar">
        <button class="active" data-tab="person">By Person</button>
        <button data-tab="platform">By Platform</button>
        <button data-tab="unmatched">Unmatched</button>
        <button data-tab="raw">Raw Matches</button>
      </div>
      <div id="view-person"></div>
      <div id="view-platform" style="display:none"></div>
      <div id="view-unmatched" style="display:none"></div>
      <div id="view-raw" style="display:none"></div>
      <div class="footer">Tip: Click a header to expand. Use your browser’s find (<span class="kbd">Ctrl/⌘+F</span>) to jump to a client.</div>
    </section>
  </main>

  <script>
    /*****************
     * Config: Teams *
     *****************/
    const TEAMS = {
      Facebook: [
        "Evarose",
        "Charlene",
        "Joshua Advincula",
        "Rainier Vann Muñoz",
        "Marie Guirjen",
        "Veronica Trigo",
        "May Muñoz",
      ],
      TikTok: [
        "Laura Dimadi",
        "Carren Evangelista",
        "Jimmy Clifford",
      ],
      YouTube: [
        "Cade Holmquist",
        "YouTube",
      ],
      "SMM (Posts)": [
        "Jasmine Garcia",
        "Krilen Andoque",
      ],
      CSM: [
        "Kizzia",
        "Anthony Jenkins",
        "Rain G",
        "Sandra Catalina Mateus Abdala",
        "Shao",
        "Preston Mast",
        "Niima Biuibrahim"
      ]
    };

    // Normalize duplicate names within team lists
    for (const k of Object.keys(TEAMS)) {
      TEAMS[k] = Array.from(new Set(TEAMS[k]));
    }

    /**********************
     * CSV Parse (vanilla)
     **********************/
    function parseCSV(text) {
      const rows = [];
      let i = 0, field = '', row = [], inQuotes = false;
      while (i < text.length) {
        const char = text[i];
        if (inQuotes) {
          if (char === '"') {
            if (text[i+1] === '"') { field += '"'; i++; }
            else { inQuotes = false; }
          } else {
            field += char;
          }
        } else {
          if (char === '"') { inQuotes = true; }
          else if (char === ',') { row.push(field); field = ''; }
          else if (char === '\n') { row.push(field); rows.push(row); field = ''; row = []; }
          else if (char === '\r') { /* ignore */ }
          else { field += char; }
        }
        i++;
      }
      if (field.length || row.length) { row.push(field); rows.push(row); }
      if (rows.length && rows[rows.length-1].length === 1 && rows[rows.length-1][0] === '') rows.pop();
      return rows;
    }

    function rowsToObjects(rows) {
      if (!rows || rows.length === 0) return [];
      const headers = rows[0].map(h => (h || '').trim());
      return rows.slice(1).map(r => {
        const obj = {}; r.forEach((v, idx) => obj[headers[idx] || `col_${idx}`] = v); return obj;
      });
    }

    function getHeaders(rows) {
      return rows && rows.length ? rows[0].map(h => (h || '').trim()) : [];
    }

    /*****************
     * File handling *
     *****************/
    const state = {
      main: { rows: null, headers: [], map: {} },
      onboard: { rows: null, headers: [], map: {} },
      stripe: { rows: null, headers: [], map: {} },
      results: null,
    };

    const fileElMain = document.getElementById('file-main');
    const fileElOnboard = document.getElementById('file-onboard');
    const fileElStripe = document.getElementById('file-stripe');

    fileElMain.addEventListener('change', () => handleFile(fileElMain.files[0], 'main', 'hint-main'));
    fileElOnboard.addEventListener('change', () => handleFile(fileElOnboard.files[0], 'onboard', 'hint-onboard'));
    fileElStripe.addEventListener('change', () => handleFile(fileElStripe.files[0], 'stripe', 'hint-stripe'));

    function handleFile(file, key, hintId) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        const text = e.target.result;
        const rows = parseCSV(text);
        const headers = getHeaders(rows);
        state[key].rows = rows;
        state[key].headers = headers;

        // Auto-map based on headers
        autoMap(key);

        document.getElementById(hintId).textContent = `${file.name} • ${rows.length - 1} data rows • ${headers.length} columns`;
        renderMappings();
        maybeEnableRun();
      };
      reader.readAsText(file);
    }

    /*****************
     * Column mapping *
     *****************/
    const MAIN_FIELDS = [
      { key: 'clientName', label: 'Client Name' },
      { key: 'email', label: 'Email' },
      { key: 'stripeId', label: 'Customer/Stripe ID' },
      { key: 'amFacebook', label: 'Facebook AMs (multiple names allowed)' },
      { key: 'amTikTok', label: 'TikTok AMs (multiple names allowed)' },
      { key: 'amYouTube', label: 'YouTube AMs (multiple names allowed)' },
      { key: 'amSMM', label: 'SMM (Posts)' },
      { key: 'amCSM', label: 'CSM' },
    ];

    const STRIPE_FIELDS = [
      { key: 'stripeId', label: 'Customer/Stripe ID' },
      { key: 'clientName', label: 'Customer Name' },
      { key: 'email', label: 'Email' },
      { key: 'amount', label: 'Amount Paid (numeric)' },
    ];

    function renderMappings() {
      const wrapMain = document.getElementById('mapping-main');
      if (state.main.headers.length) {
        wrapMain.innerHTML = mappingBlock('CSV 1 — Main Client List', 'main', state.main.headers, MAIN_FIELDS);
      } else wrapMain.innerHTML = '';

      const wrapOn = document.getElementById('mapping-onboard');
      if (state.onboard.headers.length) {
        wrapOn.innerHTML = mappingBlock('CSV 2 — Onboarding (New Clients)', 'onboard', state.onboard.headers, MAIN_FIELDS);
      } else wrapOn.innerHTML = '';

      const wrapStripe = document.getElementById('mapping-stripe');
      if (state.stripe.headers.length) {
        wrapStripe.innerHTML = mappingBlock('CSV 3 — Stripe', 'stripe', state.stripe.headers, STRIPE_FIELDS);
      } else wrapStripe.innerHTML = '';

      document.querySelectorAll('[data-map-select]').forEach(sel => {
        sel.addEventListener('change', (e) => {
          const [dataset, fieldKey] = e.target.getAttribute('data-map-select').split(':');
          state[dataset].map[fieldKey] = e.target.value || null;
          maybeEnableRun();
        });
      });
    }

    function mappingBlock(title, datasetKey, headers, fields) {
      const rows = fields.map(f => {
        const current = state[datasetKey].map[f.key] || '';
        const options = ['<option value="">— none —</option>']
          .concat(headers.map(h => {
            const enc = encodeHtml(h);
            const sel = (h === current) ? ' selected' : '';
            return `<option value="${enc}"${sel}>${enc}</option>`;
          })).join('');
        return `
          <div class="row">
            <div>
              <label>${f.label}</label>
              <select data-map-select="${datasetKey}:${f.key}">${options}</select>
            </div>
          </div>`;
      }).join('');
      return `<details open>
        <summary><div class="summary-row"><strong>${title}</strong><span class="hint">Map relevant columns</span></div></summary>
        <div style="padding:8px 4px 0">${rows}</div>
      </details>`;
    }

    function maybeEnableRun() {
      const needMain = !!state.main.rows && !!state.main.headers.length;
      const needStripe = !!state.stripe.rows && !!state.stripe.headers.length;
      const mappedSomeMain = Object.values(state.main.map || {}).filter(Boolean).length >= 2;
      const mappedStripe = ['stripeId','clientName','email','amount'].some(k => state.stripe.map[k]);
      document.getElementById('btn-run').disabled = !(needMain && needStripe && mappedSomeMain && mappedStripe);
    }

    function encodeHtml(s){ return (s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    /*****************
     * Auto-mapping  *
     *****************/
    function autoMap(datasetKey){
      const headers = state[datasetKey].headers || [];
      if (!headers.length) return;

      const H = headers.map(h => h.trim());
      const pick = (...patterns) => bestHeader(H, patterns);

      if (datasetKey === 'stripe') {
        state[datasetKey].map = {
          stripeId: pick(
            /^(stripe\s*)?(customer\s*)?id$/i,
            /^customer[_\s-]*id$/i,
            /^stripe[_\s-]*(id|customer)$/i,
            /^cust(?:omer)?[_\s-]*id$/i
          ),
          clientName: pick(
            /^customer[_\s-]*name$/i,
            /^client[_\s-]*name$/i,
            /^name$/i
          ),
          email: pick(
            /^customer[_\s-]*email$/i,
            /^client[_\s-]*email$/i,
            /^email$/i,
            /^e[-_ ]?mail$/i
          ),
          amount: pick(
            /^amount[_\s-]*(paid|total|received)?$/i,
            /^(total|gross|net)[_\s-]*amount$/i,
            /^amount$/i,
            /^amount[_\s-]*paid$/i
          ),
        };
      } else {
        state[datasetKey].map = {
          clientName: pick(
            /^client[_\s-]*name$/i,
            /^customer[_\s-]*name$/i,
            /^name$/i
          ),
          email: pick(
            /^client[_\s-]*email$/i,
            /^customer[_\s-]*email$/i,
            /^email$/i
          ),
          stripeId: pick(
            /^(stripe\s*)?(customer\s*)?id$/i,
            /^customer[_\s-]*id$/i,
            /^stripe[_\s-]*(id|customer)$/i,
            /^cust(?:omer)?[_\s-]*id$/i
          ),
          amFacebook: pick(
            /^(facebook|meta).*(am|manager|owner)$/i,
            /^fb.*(am|manager)$/i,
            /^facebook$/i
          ),
          amTikTok: pick(
            /^tiktok.*(am|manager|owner)$/i,
            /^tt.*(am|manager)$/i,
            /^tiktok$/i
          ),
          amYouTube: pick(
            /^(youtube|yt).*(am|manager|owner)$/i,
            /^(youtube|yt)$/i
          ),
          amSMM: pick(
            /^(smm|social[\s_-]*media).*(am|manager|owner)$/i,
            /^social[\s_-]*media$/i,
            /^smm$/i
          ),
          amCSM: pick(
            /^(csm|client[\s_-]*success|customer[\s_-]*success).*(am|manager|owner)$/i,
            /^(client|customer)[\s_-]*success$/i,
            /^csm$/i
          ),
        };
      }

      Object.keys(state[datasetKey].map).forEach(k => {
        if (!state[datasetKey].map[k]) delete state[datasetKey].map[k];
      });
    }

    function bestHeader(headers, patterns){
      const norm = s => (s || '').trim().toLowerCase().replace(/\s+/g,' ').replace(/[_-]/g,' ');
      const Hn = headers.map(h => norm(h));

      const testers = patterns.map(p => {
        if (p instanceof RegExp) return h => p.test(h);
        const n = norm(String(p));
        return h => norm(h) === n;
      });

      for (let i=0;i<testers.length;i++){
        const t = testers[i];
        if (!(patterns[i] instanceof RegExp)) {
          const idx = headers.findIndex(h => t(h));
          if (idx !== -1) return headers[idx];
        }
      }
      for (let i=0;i<testers.length;i++){
        const t = testers[i];
        if (patterns[i] instanceof RegExp) {
          const idx = headers.findIndex(h => t(h));
          if (idx !== -1) return headers[idx];
        }
      }
      for (let i=0;i<patterns.length;i++){
        const p = patterns[i];
        if (p instanceof RegExp) continue;
        const target = norm(String(p));
        const idx = Hn.findIndex(hn => hn.includes(target));
        if (idx !== -1) return headers[idx];
      }
      return null;
    }

    /*****************
     * Matching logic *
     *****************/
    const btnRun = document.getElementById('btn-run');
    const runStats = document.getElementById('run-stats');
    const currencyEl = document.getElementById('currency-symbol');

    btnRun.addEventListener('click', () => {
      const cfg = {
        currency: currencyEl.value || '$',
        emailNormalize: document.getElementById('email-normalize').value === 'yes',
        fuzzyMode: document.getElementById('fuzzy-mode').value, // off | loose | aggressive
      };

      const mainObjs = state.main.rows ? rowsToObjects(state.main.rows) : [];
      const onboardObjs = state.onboard.rows ? rowsToObjects(state.onboard.rows) : [];
      const stripeObjs = state.stripe.rows ? rowsToObjects(state.stripe.rows) : [];

      const mappedMain = projectMain(mainObjs, state.main.map);
      const mappedOnboard = projectMain(onboardObjs, state.onboard.map);
      const mappedStripe = projectStripe(stripeObjs, state.stripe.map);

      // mark onboarding as new
      const onboardingKeys = new Set(mappedOnboard.map(x => compositeKey(x, cfg)));

      // merge main + onboarding (de-dup by composite key) & carry platform list + assignments
      const combinedByKey = new Map();
      [...mappedMain, ...mappedOnboard].forEach(rec => {
        const key = compositeKey(rec, cfg);
        if (!combinedByKey.has(key)) {
          combinedByKey.set(key, { ...rec, platforms: new Set(), assignments: [], isNew: onboardingKeys.has(key) });
        }
        const acc = combinedByKey.get(key);

        if (!acc.clientName && rec.clientName) acc.clientName = rec.clientName;
        if (!acc.email && rec.email) acc.email = rec.email;
        if (!acc.stripeId && rec.stripeId) acc.stripeId = rec.stripeId;
        if (onboardingKeys.has(key)) acc.isNew = true;

        // Build assignments from per-team columns.
        const teamCols = [
          ['Facebook', rec.amFacebook, true],
          ['TikTok', rec.amTikTok, true],
          ['YouTube', rec.amYouTube, true],
          ['SMM (Posts)', rec.amSMM, true],
          ['CSM', rec.amCSM, false], // manager-only
        ];
        teamCols.forEach(([teamName, names, countsAsPlatform]) => {
          splitNames(names).forEach(nm => {
            acc.assignments.push({ am: nm, team: teamName });
            if (countsAsPlatform) acc.platforms.add(teamName);
          });
        });
      });

      // de-duplicate assignments per client (by name+team)
      combinedByKey.forEach(acc => {
        const uniq = new Map();
        acc.assignments.forEach(a => {
          const k = normalizeName(a.am) + '|' + (a.team || '');
          if (!uniq.has(k)) uniq.set(k, a);
        });
        acc.assignments = Array.from(uniq.values());
      });

      // Index Stripe by id/email/name; aggregate totals + transaction counts
      const stripeAgg = aggregateStripe(mappedStripe, cfg);

      const matched = [];
      const unmatched = [];

      combinedByKey.forEach(client => {
        const match = findStripeMatch(client, stripeAgg, cfg);
        const base = {
          clientName: client.clientName,
          email: client.email,
          stripeId: client.stripeId,
          platforms: Array.from(client.platforms),
          assignments: client.assignments,
          isNew: client.isNew,
        };
        if (match) {
          matched.push({
            ...base,
            amount: match.amount,
            txnCount: match.txnCount || 0,
            stripeId: match.stripeId || client.stripeId,
            email: match.email || client.email,
            clientName: client.clientName || match.clientName,
            matchedOn: match.matchType,
          });
        } else {
          unmatched.push({ ...base, txnCount: 0 });
        }
      });

      // Summaries
      const byPerson = summarizeByPerson(matched, unmatched, cfg);
      const byPlatform = summarizeByPlatform(matched, unmatched, cfg);

      state.results = { matched, unmatched, byPerson, byPlatform, cfg };

      renderPerson(byPerson, cfg);
      renderPlatform(byPlatform, cfg);
      renderUnmatched(unmatched);
      renderRaw(matched);

      const totalAmount = matched.reduce((s,x)=> s + (x.amount||0), 0);
      const totalTxns = matched.reduce((s,x)=> s + (x.txnCount||0), 0);
      runStats.innerHTML = `Matched <strong>${matched.length}</strong> client(s). Unmatched <strong>${unmatched.length}</strong>. Transactions <strong>${totalTxns}</strong>. Total paid <strong>${fmtCurrency(totalAmount, cfg.currency)}</strong>.`;

      document.getElementById('btn-export-person').disabled = false;
      document.getElementById('btn-export-platform').disabled = false;
      document.getElementById('btn-export-unmatched').disabled = false;
    });

    function splitNames(raw){
      if (!raw) return [];
      const parts = String(raw).split(/[,;\/\n]|\s+&\s+|\s+and\s+/gi).map(s => s.trim()).filter(Boolean);
      return parts;
    }

    function normalizeEmail(e){ if (!e) return ''; return (document.getElementById('email-normalize').value === 'yes') ? (''+e).trim().toLowerCase() : (''+e).trim(); }
    function normalizeName(n){ return (''+ (n||'')).trim().replace(/\s+/g,' ').toLowerCase(); }

    function compositeKey(obj, cfg){
      const id = (obj.stripeId||'').trim();
      const email = normalizeEmail(obj.email);
      const name = normalizeName(obj.clientName);
      return `${id}|${email}|${name}`;
    }

    function projectMain(rows, map){
      return rows.map(r => ({
        clientName: pick(r, map.clientName),
        email: pick(r, map.email),
        stripeId: pick(r, map.stripeId),
        amFacebook: pick(r, map.amFacebook),
        amTikTok: pick(r, map.amTikTok),
        amYouTube: pick(r, map.amYouTube),
        amSMM: pick(r, map.amSMM),
        amCSM: pick(r, map.amCSM),
      })).filter(x => x.clientName || x.email || x.stripeId);
    }

    function projectStripe(rows, map){
      return rows.map(r => ({
        stripeId: pick(r, map.stripeId),
        clientName: pick(r, map.clientName),
        email: pick(r, map.email),
        amount: parseAmount(pick(r, map.amount)),
      })).filter(x => x.stripeId || x.email || x.clientName);
    }

    function pick(row, key){ return key ? (row[key] ?? '').toString() : ''; }

    function parseAmount(v){
      if (v == null) return 0;
      if (typeof v === 'number') return v;
      const s = (''+v).replace(/[^0-9.,-]/g,'').replace(/,/g,'');
      const n = parseFloat(s);
      return isNaN(n) ? 0 : n;
    }

    // Aggregate Stripe amounts & transaction counts by best available key
    function aggregateStripe(list, cfg){
      const byId = new Map();
      const byEmail = new Map();
      const byName = new Map();
      list.forEach(x => {
        const keyId = (x.stripeId||'').trim();
        const keyEmail = normalizeEmail(x.email);
        const keyName = normalizeName(x.clientName);

        // Reuse an existing obj if we've seen this customer by any key
        const obj = byId.get(keyId) || byEmail.get(keyEmail) || byName.get(keyName) || {
          amount: 0,
          txnCount: 0,
          clientName: x.clientName,
          email: x.email,
          stripeId: x.stripeId
        };

        obj.amount += x.amount || 0;
        obj.txnCount += 1;
        obj.clientName = obj.clientName || x.clientName;
        obj.email = obj.email || x.email;
        obj.stripeId = obj.stripeId || x.stripeId;

        if (keyId) byId.set(keyId, obj);
        if (keyEmail) byEmail.set(keyEmail, obj);
        if (keyName) byName.set(keyName, obj);
      });
      return { byId, byEmail, byName };
    }

    function findStripeMatch(client, stripeAgg, cfg){
      const idKey = (client.stripeId||'').trim();
      if (idKey && stripeAgg.byId.has(idKey)) return { ...stripeAgg.byId.get(idKey), matchType: 'Customer ID' };
      const emailKey = normalizeEmail(client.email);
      if (emailKey && stripeAgg.byEmail.has(emailKey)) return { ...stripeAgg.byEmail.get(emailKey), matchType: 'Email' };
      const nameKey = normalizeName(client.clientName);
      if (nameKey && stripeAgg.byName.has(nameKey)) return { ...stripeAgg.byName.get(nameKey), matchType: 'Name (normalized)' };
      if (cfg.fuzzyMode !== 'off' && nameKey) {
        const candidates = Array.from(stripeAgg.byName.keys());
        let best = null; let bestScore = 0;
        for (const cand of candidates) {
          const score = similarity(nameKey, cand);
          if (score > bestScore) { bestScore = score; best = cand; }
        }
        const minScore = (cfg.fuzzyMode === 'aggressive') ? 0.72 : 0.82;
        if (best && bestScore >= minScore) {
          return { ...stripeAgg.byName.get(best), matchType: `Name (fuzzy ${Math.round(bestScore*100)}%)` };
        }
      }
      return null;
    }

    // Lightweight similarity
    function similarity(a, b){
      if (!a || !b) return 0;
      if (a === b) return 1;
      const sa = new Set(a.split(/\s+/));
      const sb = new Set(b.split(/\s+/));
      const inter = [...sa].filter(x => sb.has(x)).length;
      const union = new Set([...sa, ...sb]).size;
      const tokenScore = inter / union;
      const ca = new Set(a);
      const cb = new Set(b);
      const interC = [...ca].filter(x => cb.has(x)).length;
      const charScore = interC / Math.max(ca.size, cb.size);
      return 0.6*tokenScore + 0.4*charScore;
    }

    /*****************
     * Summarization *
     *****************/
    function locateTeamFor(am){
      for (const [team, members] of Object.entries(TEAMS)) {
        if (members.some(m => sameName(m, am))) return team;
      }
      return 'Other';
    }

    function sameName(a,b){ return normalizeName(a) === normalizeName(b); }

    function summarizeByPerson(matched, unmatched, cfg){
      const people = new Map();
      function ensure(am){ if (!people.has(am)) people.set(am, { team: locateTeamFor(am), clients: [], unmatched: [], total: 0, txns: 0 }); return people.get(am); }

      matched.forEach(m => {
        const ams = uniqueAms(m.assignments);
        ams.forEach(am => {
          const p = ensure(am);
          p.clients.push(m);
          p.total += (m.amount || 0);
          p.txns += (m.txnCount || 0);
        });
      });

      unmatched.forEach(u => {
        const ams = uniqueAms(u.assignments);
        if (ams.length === 0) ams.push('Unassigned');
        ams.forEach(am => {
          const p = ensure(am);
          p.unmatched.push(u);
        });
      });

      return Array.from(people.entries()).map(([am, data]) => ({ am, ...data }))
        .sort((a,b) => a.team.localeCompare(b.team) || a.am.localeCompare(b.am));
    }

    function uniqueAms(assignments){
      return Array.from(new Set((assignments||[]).map(a => a.am).filter(Boolean)));
    }

    function summarizeByPlatform(matched, unmatched, cfg){
      const byPlat = new Map();
      function ensure(plat){ if (!byPlat.has(plat)) byPlat.set(plat, { clients: [], unmatched: [], total: 0, txns: 0 }); return byPlat.get(plat); }

      // Only these count as platforms
      const knownPlats = new Set(['Facebook','TikTok','YouTube','SMM (Posts)']);

      matched.forEach(m => {
        const plats = (m.platforms && m.platforms.length) ? m.platforms : ['Other'];
        const unique = Array.from(new Set(plats));
        unique.forEach(p => {
          const key = knownPlats.has(p) ? p : 'Other';
          const bucket = ensure(key);
          bucket.clients.push(m);
          bucket.total += (m.amount||0);
          bucket.txns += (m.txnCount||0);
        });
      });

      unmatched.forEach(u => {
        const plats = (u.platforms && u.platforms.length) ? u.platforms : ['Other'];
        const unique = Array.from(new Set(plats));
        unique.forEach(p => {
          const key = knownPlats.has(p) ? p : 'Other';
          const bucket = ensure(key);
          bucket.unmatched.push(u);
        });
      });

      return Array.from(byPlat.entries()).map(([platform, data]) => ({ platform, ...data }))
        .sort((a,b) => a.platform.localeCompare(b.platform));
    }

    /**********
     * Render *
     **********/
    function renderPerson(list, cfg){
      const root = document.getElementById('view-person');
      if (!list || !list.length) { root.innerHTML = '<div class="hint">No results yet.</div>'; return; }

      const byTeam = new Map();
      list.forEach(x => {
        const t = x.team || 'Other';
        if (!byTeam.has(t)) byTeam.set(t, []);
        byTeam.get(t).push(x);
      });

      let html = '';
      const teamOrder = ['Facebook','TikTok','YouTube','SMM (Posts)','CSM','Other','Unassigned'];

      Array.from(byTeam.entries()).sort((a,b)=> teamOrder.indexOf(a[0]) - teamOrder.indexOf(b[0])).forEach(([team, arr]) => {
        const teamTotal = arr.reduce((s,p)=> s + p.total, 0);
        const teamTxns = arr.reduce((s,p)=> s + p.txns, 0);
        html += `<details open>
          <summary>
            <div class="summary-row">
              <div><span class="tag ${teamTagCls(team)}">${team}</span> • ${arr.length} person(s)</div>
              <div class="badge">Txns: ${teamTxns} • Total: ${fmtCurrency(teamTotal, cfg.currency)}</div>
            </div>
          </summary>
          <div style="padding:8px 2px 2px">`;

        arr.forEach(p => {
          const total = p.total;
          const txns = p.txns;
          html += `<details>
            <summary>
              <div class="summary-row">
                <div><strong>${encodeHtml(p.am)}</strong> <span class="hint">(${p.clients.length} matched, ${p.unmatched.length} unmatched)</span></div>
                <div class="badge">Txns: ${txns} • ${fmtCurrency(total, cfg.currency)}</div>
              </div>
            </summary>
            <div style="overflow:auto">
              ${tableClients(p.clients, cfg)}
              ${p.unmatched.length ? `<div class="hint" style="margin-top:8px">Unmatched assigned to ${encodeHtml(p.am)} (${p.unmatched.length}):</div>` : ''}
              ${p.unmatched.length ? tableClients(p.unmatched, cfg, true) : ''}
            </div>
          </details>`;
        });

        html += `</div></details>`;
      });

      root.innerHTML = html;
    }

    function renderPlatform(list, cfg){
      const root = document.getElementById('view-platform');
      if (!list || !list.length) { root.innerHTML = '<div class="hint">No results yet.</div>'; return; }

      let html = '';
      list.forEach(x => {
        const total = x.total;
        const txns = x.txns;
        html += `<details>
          <summary>
            <div class="summary-row">
              <div>${platformTag(x.platform)} <span class="hint">(${x.clients.length} matched, ${x.unmatched.length} unmatched)</span></div>
              <div class="badge">Txns: ${txns} • ${fmtCurrency(total, cfg.currency)}</div>
            </div>
          </summary>
          <div style="overflow:auto">
            ${tableClients(x.clients, cfg)}
            ${x.unmatched.length ? `<div class="hint" style="margin-top:8px">Unmatched on ${encodeHtml(x.platform)} (${x.unmatched.length}):</div>` : ''}
            ${x.unmatched.length ? tableClients(x.unmatched, cfg, true) : ''}
          </div>
        </details>`;
      });

      root.innerHTML = html;
    }

    function renderUnmatched(unmatched){
      const root = document.getElementById('view-unmatched');
      if (!unmatched || !unmatched.length) { root.innerHTML = '<div class="hint">All set—no unmatched clients. 🎉</div>'; return; }
      root.innerHTML = tableClients(unmatched, { currency: '' }, true);
    }

    function renderRaw(list){
      const root = document.getElementById('view-raw');
      if (!list || !list.length) { root.innerHTML = '<div class="hint">No matches yet.</div>'; return; }
      const rows = list.map(x => ({
        Managers: uniqueAms(x.assignments).join(', '),
        Client: x.clientName || '',
        Email: x.email || '',
        StripeID: x.stripeId || '',
        Platforms: (x.platforms||[]).join(', '),
        Transactions: x.txnCount || 0,
        New: x.isNew ? 'Yes' : 'No',
        MultiPlatform: (x.platforms||[]).length > 1 ? 'Yes' : 'No',
        Amount: x.amount || 0,
        MatchedOn: x.matchedOn || '',
      }));
      root.innerHTML = tableFromObjects(rows);
    }

    function teamTagCls(team){
      const t = (team||'').toLowerCase();
      if (t==='facebook') return 'fb';
      if (t==='tiktok') return 'tt';
      if (t==='youtube') return 'yt';
      if (t==='smm (posts)') return 'smm';
      if (t==='csm') return 'csm';
      return '';
    }

    function platformTag(p){
      const cls = teamTagCls(p);
      return `<span class="tag ${cls}">${encodeHtml(p)}</span>`;
    }

    function tableClients(arr, cfg, showZero){
      if (!arr || !arr.length) return '<div class="hint">None.</div>';
      const rows = arr.map(x => {
        const platforms = (x.platforms||[]).join(', ');
        const multi = (x.platforms||[]).length > 1;
        const ams = uniqueAms(x.assignments).join(', ');
        const amount = x.amount || 0;
        const txns = x.txnCount || 0;
        const amtStr = amount ? fmtCurrency(amount, cfg.currency) : (showZero ? fmtCurrency(0, cfg.currency) : '—');
        const pills = [ x.isNew ? '<span class="pill new">New</span>' : '', multi ? '<span class="pill multi">Multi-Platform</span>' : '' ].filter(Boolean).join(' ');
        return `<tr>
          <td>${encodeHtml(ams || 'Unassigned')}</td>
          <td>${encodeHtml(x.clientName || '')} ${pills}</td>
          <td>${encodeHtml(x.email || '')}</td>
          <td>${encodeHtml(x.stripeId || '')}</td>
          <td>${encodeHtml(platforms || '')}</td>
          <td class="right">${txns || (showZero ? 0 : '—')}</td>
          <td class="right">${amtStr}</td>
        </tr>`;
      }).join('');
      return `<table>
        <thead><tr><th>AM(s)/CSM(s)</th><th>Client</th><th>Email</th><th>Stripe ID</th><th>Platforms</th><th class="right">Transactions</th><th class="right">Amount Paid</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>`;
    }

    function tableFromObjects(list){
      if (!list.length) return '<div class="hint">No data.</div>';
      const headers = Object.keys(list[0]);
      const thead = '<tr>' + headers.map(h => `<th>${encodeHtml(h)}</th>`).join('') + '</tr>';
      const tbody = list.map(obj => '<tr>' + headers.map(h => `<td>${encodeHtml(String(obj[h] ?? ''))}</td>`).join('') + '</tr>').join('');
      return `<table><thead>${thead}</thead><tbody>${tbody}></tbody></table>`;
    }

    function fmtCurrency(n, sym){
      const sign = n < 0 ? '-' : '';
      const v = Math.abs(n);
      return `${sign}${sym}${v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    }

    /***********
     * Export  *
     ***********/
    function toCSV(rows){
      if (!rows.length) return '';
      const headers = Object.keys(rows[0]);
      const esc = v => '"' + (String(v ?? '').replace(/"/g,'""')) + '"';
      const head = headers.map(esc).join(',');
      const body = rows.map(r => headers.map(h => esc(r[h])).join(',')).join('\n');
      return head + '\n' + body;
    }

    document.getElementById('btn-export-person').addEventListener('click', () => {
      const res = state.results; if (!res) return;
      const rows = [];
      res.byPerson.forEach(p => {
        (p.clients || []).forEach(c => rows.push({
          Team: p.team,
          Manager: p.am,
          Client: c.clientName || '',
          Email: c.email || '',
          StripeID: c.stripeId || '',
          Platforms: (c.platforms||[]).join(', '),
          Transactions: c.txnCount || 0,
          New: c.isNew ? 'Yes' : 'No',
          Amount: c.amount || 0,
          MatchedOn: c.matchedOn || '',
        }));
        (p.unmatched || []).forEach(u => rows.push({
          Team: p.team,
          Manager: p.am,
          Client: u.clientName || '',
          Email: u.email || '',
          StripeID: u.stripeId || '',
          Platforms: (u.platforms||[]).join(', '),
          Transactions: 0,
          New: u.isNew ? 'Yes' : 'No',
          Amount: 0,
          MatchedOn: '—',
        }));
      });
      download('summary_by_person.csv', toCSV(rows));
    });

    document.getElementById('btn-export-platform').addEventListener('click', () => {
      const res = state.results; if (!res) return;
      const rows = [];
      res.byPlatform.forEach(p => {
        (p.clients || []).forEach(c => rows.push({
          Platform: p.platform,
          Managers: uniqueAms(c.assignments).join(', '),
          Client: c.clientName || '',
          Email: c.email || '',
          StripeID: c.stripeId || '',
          Platforms: (c.platforms||[]).join(', '),
          Transactions: c.txnCount || 0,
          New: c.isNew ? 'Yes' : 'No',
          Amount: c.amount || 0,
          MatchedOn: c.matchedOn || '',
        }));
        (p.unmatched || []).forEach(u => rows.push({
          Platform: p.platform,
          Managers: uniqueAms(u.assignments).join(', '),
          Client: u.clientName || '',
          Email: u.email || '',
          StripeID: u.stripeId || '',
          Platforms: (u.platforms||[]).join(', '),
          Transactions: 0,
          New: u.isNew ? 'Yes' : 'No',
          Amount: 0,
          MatchedOn: '—',
        }));
      });
      download('summary_by_platform.csv', toCSV(rows));
    });

    document.getElementById('btn-export-unmatched').addEventListener('click', () => {
      const res = state.results; if (!res) return;
      const rows = (res.unmatched || []).map(u => ({
        Managers: uniqueAms(u.assignments).join(', ') || 'Unassigned',
        Client: u.clientName || '',
        Email: u.email || '',
        StripeID: u.stripeId || '',
        Platforms: (u.platforms||[]).join(', '),
        Transactions: 0,
        New: u.isNew ? 'Yes' : 'No',
      }));
      download('unmatched.csv', toCSV(rows));
    });

    function download(filename, text){
      const blob = new Blob([text], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    }

    /*********
     * Tabs  *
     *********/
    document.querySelectorAll('.tabbar button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tabbar button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const tab = btn.getAttribute('data-tab');
        document.getElementById('view-person').style.display = (tab==='person') ? '' : 'none';
        document.getElementById('view-platform').style.display = (tab==='platform') ? '' : 'none';
        document.getElementById('view-unmatched').style.display = (tab==='unmatched') ? '' : 'none';
        document.getElementById('view-raw').style.display = (tab==='raw') ? '' : 'none';
      });
    });
  </script>
</body>
</html>
