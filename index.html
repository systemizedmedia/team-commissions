<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AM & SMM Summaries — Fixed Roster (Paid Stripe Only)</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    :root { --bg:#0b1020; --card:#121931; --muted:#9fb0c0; --text:#eef3f8; --accent:#6aa3ff; --hl:#1d305f; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    header { padding:24px; border-bottom:1px solid #1d2748; }
    h1 { margin:0 0 6px; font-size:20px; }
    p.sub { margin:0; font-size:13px; color:var(--muted); }
    main { padding:24px; display:grid; gap:16px; grid-template-columns: 1fr; max-width:1200px; margin:0 auto; }
    .card { background:var(--card); border:1px solid #1d2748; border-radius:16px; padding:16px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:end; }
    label { font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    input[type=file] { width:100%; background:#0c1430; color:var(--text); border:1px solid #223158; border-radius:10px; padding:10px 12px; }
    button { background:linear-gradient(180deg, #2b58ff, #0049ff); color:white; border:none; padding:12px 16px; border-radius:12px; font-weight:600; cursor:pointer; }
    button.ghost { background:transparent; border:1px solid #2b58ff; color:#cfe0ff; }
    table { width:100%; border-collapse:collapse; }
    th, td { border-bottom:1px solid #1d2748; padding:10px; font-size:13px; text-align:left; vertical-align:top; }
    th { color:#cfe0ff; font-weight:600; }
    .muted { color:var(--muted); }
    .sectionTitle { margin:0 0 8px; }
    .personBox { border:1px solid #1d2748; border-radius:12px; padding:12px; margin:10px 0 18px; background:#0e1530; }
    .personBox h4 { margin:0 0 6px; font-size:15px; }
    .totals { margin:4px 0 10px; font-size:13px; color:#e5efff; }
    .grid-2 { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    @media (max-width: 900px){ .grid-2{ grid-template-columns:1fr; } }
    footer { padding:18px 24px; color:#90a6bd; font-size:12px; text-align:center; }
    .sumline { margin:6px 0 10px; font-size:13px; color:#cfe0ff; }
  </style>
</head>
<body>
  <header>
    <h1>AM & SMM Summaries — Fixed Roster</h1>
    <p class="sub">Upload <strong>Monday Active</strong>, <strong>Monday Onboarding</strong> (new clients), and <strong>Stripe</strong> CSVs. Matching priority: <code>Stripe ID (cus_*)</code> → email → name → fuzzy. Stripe counts only paid/succeeded/complete-like statuses. No revenue splitting.</p>
  </header>

  <main>
    <section class="card">
      <div class="row">
        <div class="col" style="flex:1 1 260px; min-width:260px;">
          <label>1) Monday — Active Clients CSV</label>
          <input type="file" id="mondayActive" accept=".csv" />
        </div>
        <div class="col" style="flex:1 1 260px; min-width:260px;">
          <label>2) Monday — Onboarding (New Clients) CSV</label>
          <input type="file" id="mondayOnboarding" accept=".csv" />
        </div>
        <div class="col" style="flex:1 1 260px; min-width:260px;">
          <label>3) Stripe — Transactions CSV</label>
          <input type="file" id="stripeCsv" accept=".csv" />
        </div>
      </div>
      <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;">
        <button id="go">Generate</button>
        <button class="ghost" id="dlFB" disabled>Download: Facebook AMs (CSV)</button>
        <button class="ghost" id="dlTT" disabled>Download: TikTok AMs (CSV)</button>
        <button class="ghost" id="dlYT" disabled>Download: YouTube AMs (CSV)</button>
        <button class="ghost" id="dlSMM" disabled>Download: SMM (CSV)</button>
        <button class="ghost" id="dlOnb" disabled>Download: Onboarding Summary (CSV)</button>
        <button class="ghost" id="dlUnmatched" disabled>Download: Unmatched Paid Stripe Rows (CSV)</button>
      </div>
    </section>

    <!-- Platform sections -->
    <section class="card">
      <h3 class="sectionTitle">Facebook AMs — Per-Person</h3>
      <div id="fbWrap"></div>
    </section>
    <section class="card">
      <h3 class="sectionTitle">TikTok AMs — Per-Person</h3>
      <div id="ttWrap"></div>
    </section>
    <section class="card">
      <h3 class="sectionTitle">YouTube AMs — Per-Person</h3>
      <div id="ytWrap"></div>
    </section>
    <section class="card">
      <h3 class="sectionTitle">SMM (Posts) — Per-Person</h3>
      <div id="smmWrap"></div>
    </section>

    <!-- Onboarding summary -->
    <section class="card">
      <h3 class="sectionTitle">Onboarding — New Clients (no assignments)</h3>
      <div id="onbWrap"></div>
    </section>

    <!-- Log -->
    <section class="card">
      <h3 class="sectionTitle">Run Log</h3>
      <pre id="log" class="muted" style="white-space:pre-wrap; margin:0;"></pre>
    </section>
  </main>

  <footer>No data leaves your browser. Built for GitHub Pages / local use.</footer>

  <script>
    // ---------- FIXED ROSTERS (edit here if your teams change) ----------
    const ROSTERS = {
      FB:  ["Evarose","Charlene","Joshua Advincula","Rainier Vann Muñoz","Marie Guirjen","Veronica Trigo","May Muñoz"],
      TT:  ["Laura Dimadi","Carren Evangelista"],
      YT:  ["Cade Holmquist","YouTube"],
      SMM: ["Jasmine Garcia","Krilen Andoque"],
    };
    // -------------------------------------------------------------------

    const $ = (sel) => document.querySelector(sel);
    const logEl = $("#log");
    const appendLog = (msg) => { logEl.textContent += msg + "\\n"; };

    // Utils
    function normalize(s){
      if(!s) return "";
      s = String(s).toLowerCase().normalize("NFKD").replace(/[\\u0300-\\u036f]/g, "");
      s = s.replace(/&/g, " and ").replace(/[^a-z0-9]+/g, " ").trim();
      return s;
    }
    const tokens = (s) => new Set(normalize(s).split(" ").filter(Boolean));
    const toFloat = (x) => {
      if(x==null) return NaN;
      const s = String(x).replace(/,/g, "");
      const m = s.match(/[0-9.-]+/g);
      if(!m) return NaN;
      return parseFloat(m.join(""));
    };
    const fmt = (n) => {
      if(!isFinite(n)) return '0.00';
      try { return new Intl.NumberFormat('en-US',{minimumFractionDigits:2, maximumFractionDigits:2}).format(n); }
      catch { return (Math.round(n*100)/100).toFixed(2); }
    };

    function headerRowIndex(data){
      for(let i=0;i<Math.min(10, data.length);i++){
        const row = data[i].map(v => (v||"").toString().trim());
        if(row.includes("Name") || row.includes("Client Name")) return i;
        if(row.includes("FB AM") || row.includes("TT AM") || row.includes("YT AM") || row.includes("SMM")) return i;
      }
      return 0;
    }

    function csvToObjectsWithHeaderGuess(file){
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          complete: (res) => {
            const rows = res.data.filter(r => r.length && r.some(cell => (cell||"").toString().trim() !== ""));
            if(rows.length === 0){ return resolve([]); }
            const hdrIdx = headerRowIndex(rows);
            const headers = rows[hdrIdx].map(h => (h||"").toString().trim());
            const objs = [];
            for(let i = hdrIdx + 1; i < rows.length; i++){
              const r = rows[i];
              const obj = {};
              headers.forEach((h, idx) => obj[h || `col_${idx}`] = r[idx]);
              const hasAny = Object.values(obj).some(v => String(v||"").trim() !== "");
              if(hasAny) objs.push(obj);
            }
            resolve(objs);
          },
          error: (err) => reject(err)
        });
      });
    }

    // pick people from a cell using fixed roster
    function pickAssignedAll(rawCell, roster){
      if(!rawCell) return [];
      const out = [];
      const parts = String(rawCell).split(/[,/;]| and /i).map(s => s.trim()).filter(Boolean);
      const normRoster = roster.map(n => ({n, k: normalize(n)}));
      for(const p of parts){
        const np = normalize(p);
        // exact or token-inclusive match
        const pt = tokens(np);
        for(const r of normRoster){
          const rt = tokens(r.k);
          const ptInR = [...pt].every(tok => rt.has(tok));
          const rInPt = [...rt].every(tok => pt.has(tok));
          if(r.k === np || ptInR || rInPt){ out.push(r.n); }
        }
      }
      // dedup keep order
      return out.filter((v, i, a) => a.indexOf(v) === i);
    }

    function activeFlag(val, headerEcho){
      if(val == null) return false;
      const s = String(val).trim();
      if(!s) return false;
      if(headerEcho && s.toLowerCase() === headerEcho.toLowerCase()) return false;
      if(['false','no','0'].includes(s.toLowerCase())) return false;
      return true;
    }

    function servicesFromRow(row){
      const svcCols = {
        Facebook: 'Facebook Service',
        TikTok: 'TikTok',
        YouTube: 'Youtube Service',
        Posts: 'Organic Post Service',
      };
      const out = [];
      for(const [svc, col] of Object.entries(svcCols)){
        if(col in row && activeFlag(row[col], col)) out.push(svc);
      }
      return out;
    }

    function clientNameFromMondayRow(row){
      if('Client Name' in row && String(row['Client Name']).trim() !== '') return String(row['Client Name']).trim();
      if('Name' in row){ return String(row['Name']).replace(/^Main\\s*-\\s*/i, '').trim(); }
      return '';
    }

    function normalizeMondayActive(objs){
      return objs.map(row => {
        const clientName = clientNameFromMondayRow(row);
        return {
          stage: 'Active',
          client_name: clientName,
          client_key: normalize(clientName),
          email: (row['Email'] || '').toString().trim().toLowerCase(),
          stripe_id: (row['Stripe ID'] || '').toString().trim().toLowerCase(),
          services: servicesFromRow(row),
          fb_ams: pickAssignedAll(row['FB AM'], ROSTERS.FB),
          tt_ams: pickAssignedAll(row['TT AM'], ROSTERS.TT),
          yt_ams: pickAssignedAll(row['YT AM'], ROSTERS.YT),
          smms:   pickAssignedAll(row['SMM'],   ROSTERS.SMM),
        };
      }).filter(r => r.client_key && !['client name','name','stripe id'].includes(r.client_key));
    }

    function normalizeMondayOnboarding(objs){
      return objs.map(row => {
        const clientName = clientNameFromMondayRow(row);
        return {
          stage: 'Onboarding',
          client_name: clientName,
          client_key: normalize(clientName),
          email: (row['Email'] || '').toString().trim().toLowerCase(),
          stripe_id: '',
          services: servicesFromRow(row),
        };
      }).filter(r => r.client_key && !['client name','name','stripe id'].includes(r.client_key));
    }

    function extractStripeCustomerId(obj){
      const direct = obj['Customer ID'] || obj['Customer Id'] || obj['Customer'] || obj['customer_id'] || obj['customer'];
      const tryStr = (v) => {
        if(!v) return '';
        const m = String(v).match(/cus_[a-z0-9]+/i);
        return m ? m[0].toLowerCase() : '';
      };
      let id = tryStr(direct);
      if(id) return id;
      for(const v of Object.values(obj)){
        const m = tryStr(v);
        if(m) return m;
      }
      return '';
    }

    function normalizeStripe(stripeObjs){
      return stripeObjs.map(row => {
        const status = (row['Status'] || '').toString().toLowerCase();
        const isPaid = ['paid','succeeded','success','captured','complete','completed','true'].some(w => status.includes(w));
        const custName = (row['Customer Description'] || '').toString();
        const custEmail = (row['Customer Email'] || '').toString().trim().toLowerCase();
        const customerId = extractStripeCustomerId(row);
        return {
          charge_id: row['id'] || row['charge_id'] || row['Charge ID'] || '',
          created_utc: row['Created date (UTC)'] || row['created_utc'] || row['Created'] || '',
          amount: toFloat(row['Amount']),
          currency: row['Currency'] || row['currency'] || 'usd',
          status: row['Status'] || '',
          is_paid: isPaid,
          customer_name: custName,
          customer_email: custEmail,
          customer_id: customerId,
          client_key: normalize(custName),
        };
      });
    }

    function buildIndexes(active, onboarding){
      const byStripeId = new Map(); // Active only (Stripe ID lives there)
      const byEmail = new Map();    // prefer Active; fallback Onboarding
      const byClientKey = new Map();// prefer Active; fallback Onboarding
      for(const r of active){
        if(r.stripe_id) byStripeId.set(r.stripe_id, r);
        if(r.email && !byEmail.has(r.email)) byEmail.set(r.email, r);
        if(r.client_key && !byClientKey.has(r.client_key)) byClientKey.set(r.client_key, r);
      }
      for(const r of onboarding){
        if(r.email && !byEmail.has(r.email)) byEmail.set(r.email, r);
        if(r.client_key && !byClientKey.has(r.client_key)) byClientKey.set(r.client_key, r);
      }
      return { byStripeId, byEmail, byClientKey };
    }

    function fuzzyGuessClientKey(sKey, byClientKey){
      if(!sKey) return null;
      const t = tokens(sKey);
      if(t.size === 0) return null;
      let bestKey = null, bestScore = 0;
      for(const [key] of byClientKey.entries()){
        const tk = tokens(key);
        const inter = [...t].filter(x => tk.has(x)).length;
        const score = inter / Math.max(t.size, tk.size);
        if(score > bestScore){ bestScore = score; bestKey = key; }
      }
      return bestScore >= 0.5 ? bestKey : null;
    }

    function computePaidTotals(clientMap, matchedRows){
      const totals = new Map(); // client_key -> {sum, count, first, last}
      for(const r of matchedRows){
        if(!clientMap.has(r.client_key)) continue; // only attribute to known clients
        const amt = Number(r.amount || 0);
        const dt = r.created_utc ? new Date(r.created_utc) : null;
        if(!totals.has(r.client_key)){ totals.set(r.client_key, { sum: 0, count: 0, first: null, last: null }); }
        const e = totals.get(r.client_key);
        if(!isNaN(amt)) e.sum += amt;
        e.count += 1;
        if(dt && !isNaN(dt)){
          if(!e.first || dt < e.first) e.first = dt;
          if(!e.last  || dt > e.last)  e.last  = dt;
        }
      }
      return totals;
    }

    // Build per-person lists for a given platform; make sure EVERY roster person appears
    function buildPerPerson(activeList, paidTotals, platformKey, rosterNames, onboardingSet){
      const per = new Map();
      // seed empty lists so everyone shows up
      for(const name of rosterNames){ per.set(name, []); }

      for(const a of activeList){
        const svcs = a.services || [];
        const hasSvc =
          platformKey === 'Facebook' ? svcs.includes('Facebook') :
          platformKey === 'TikTok'   ? svcs.includes('TikTok')   :
          platformKey === 'YouTube'  ? svcs.includes('YouTube')  :
          platformKey === 'Posts'    ? svcs.includes('Posts')    : false;
        if(!hasSvc) continue;

        let people = [];
        if(platformKey === 'Facebook') people = a.fb_ams || [];
        if(platformKey === 'TikTok')   people = a.tt_ams || [];
        if(platformKey === 'YouTube')  people = a.yt_ams || [];
        if(platformKey === 'Posts')    people = a.smms   || [];
        if(people.length === 0) continue;

        const tot = paidTotals.get(a.client_key);
        const revenue = tot ? tot.sum : 0;
        const txCount = tot ? tot.count : 0;
        const first = tot && tot.first ? tot.first.toISOString() : '';
        const last  = tot && tot.last  ? tot.last.toISOString()  : '';
        const stage = onboardingSet.has(a.client_key) ? 'Onboarding' : 'Active';

        for(const person of people){
          if(!per.has(person)) per.set(person, []); // in case roster changed
          per.get(person).push({
            Person: person,
            Client: a.client_name,
            Email: a.email || '',
            Stripe_ID: a.stripe_id || '',
            Stage: stage,
            Services: svcs.join('; '),
            Revenue_Paid: revenue > 0 ? revenue.toFixed(2) : 'Not paid',
            Revenue_Paid_Value: revenue,
            Paid_Txns: txCount,
            First_Paid_Date: first,
            Last_Paid_Date: last
          });
        }
      }

      // sort each person's list by client name
      for(const [p, rows] of per.entries()){
        rows.sort((x,y)=> x.Client.localeCompare(y.Client));
      }
      return per;
    }

    function renderPerPerson(mapPersonRows, wrapSel){
      const wrap = document.querySelector(wrapSel);
      wrap.innerHTML = '';
      for(const [person, rows] of Array.from(mapPersonRows.entries()).sort((a,b)=> a[0].localeCompare(b[0]))){
        const box = document.createElement('div');
        box.className = 'personBox';
        const h = document.createElement('h4');
        h.textContent = person;
        box.appendChild(h);

        const total = rows.reduce((acc, r) => acc + (Number(r.Revenue_Paid_Value)||0), 0);
        const paidClients = rows.filter(r => (Number(r.Revenue_Paid_Value)||0) > 0).length;
        const totalsP = document.createElement('div');
        totalsP.className = 'totals';
        totalsP.innerHTML = `<strong>Total Paid Revenue:</strong> ${fmt(total)}  •  <strong>Clients:</strong> ${rows.length}  •  <strong>Clients Paid:</strong> ${paidClients}`;
        box.appendChild(totalsP);

        const visibleHeaders = ["Person","Client","Email","Stripe_ID","Stage","Services","Revenue_Paid","Paid_Txns","First_Paid_Date","Last_Paid_Date"];
        const thead = '<thead><tr>'+visibleHeaders.map(h=>`<th>${h}</th>`).join('')+'</tr></thead>';
        const tbody = '<tbody>' + rows.map(r =>
          '<tr>'+visibleHeaders.map(h=>`<td>${r[h] ?? ''}</td>`).join('')+'</tr>'
        ).join('') + '</tbody>';
        const tbl = document.createElement('table');
        tbl.innerHTML = thead + tbody;
        box.appendChild(tbl);

        wrap.appendChild(box);
      }
      if(mapPersonRows.size === 0){ wrap.innerHTML = '<p class="muted">No data.</p>'; }
    }

    function flattenPerPersonForCsv(mapPersonRows){
      const out = [];
      for(const [person, rows] of mapPersonRows.entries()){
        const total = rows.reduce((acc, r) => acc + (Number(r.Revenue_Paid_Value)||0), 0);
        out.push({Person: person, Client:'—TOTAL—', Email:'', Stripe_ID:'', Stage:'', Services:'', Revenue_Paid: total.toFixed(2), Paid_Txns:'', First_Paid_Date:'', Last_Paid_Date:''});
        for(const r of rows){
          const { Revenue_Paid_Value, ...rest } = r;
          out.push(rest);
        }
      }
      // stable order: Person asc, keep total first per person
      out.sort((a,b)=> (a.Person||'').localeCompare(b.Person||'') || ((a.Client==='—TOTAL—')? -1 : 0));
      return out;
    }

    function buildOnboardingSummary(onboardingList, paidTotals){
      // one row per onboarding client
      const rows = onboardingList.map(o => {
        const tot = paidTotals.get(o.client_key);
        const revenue = tot ? tot.sum : 0;
        const txCount = tot ? tot.count : 0;
        const first = tot && tot.first ? tot.first.toISOString() : '';
        const last  = tot && tot.last  ? tot.last.toISOString()  : '';
        return {
          Client: o.client_name,
          Email: o.email || '',
          Stripe_ID: o.stripe_id || '',
          Stage: 'Onboarding',
          Services: (o.services||[]).join('; '),
          Revenue_Paid: revenue > 0 ? revenue.toFixed(2) : 'Not paid',
          Revenue_Paid_Value: revenue,
          Paid_Txns: txCount,
          First_Paid_Date: first,
          Last_Paid_Date: last
        };
      }).sort((a,b)=> a.Client.localeCompare(b.Client));
      const total = rows.reduce((acc, r)=> acc + (Number(r.Revenue_Paid_Value)||0), 0);
      return { rows, total };
    }

    function renderOnboardingSummary(summary, wrapSel){
      const wrap = document.querySelector(wrapSel);
      wrap.innerHTML = '';
      const { rows, total } = summary || { rows: [], total: 0 };
      const line = document.createElement('div');
      line.className = 'sumline';
      line.innerHTML = `<strong>Total Paid Revenue (Onboarding):</strong> ${fmt(total)}  •  <strong>Clients:</strong> ${rows.length}`;
      wrap.appendChild(line);

      if(rows.length === 0){ wrap.insertAdjacentHTML('beforeend','<p class="muted">No onboarding clients found.</p>'); return; }

      const headers = Object.keys(rows[0]).filter(h => h !== 'Revenue_Paid_Value');
      let html = '<div style="overflow:auto"><table><thead><tr>' +
        headers.map(h => `<th>${h}</th>`).join('') +
        '</tr></thead><tbody>';
      html += rows.map(r => '<tr>' + headers.map(h => `<td>${r[h] ?? ''}</td>`).join('') + '</tr>').join('');
      html += '</tbody></table></div>';
      wrap.insertAdjacentHTML('beforeend', html);
    }

    function flattenOnboardingForCsv(summary){
      const { rows, total } = summary || { rows: [], total: 0 };
      return [{Client:'—TOTAL—', Email:'', Stripe_ID:'', Stage:'Onboarding', Services:'', Revenue_Paid: total.toFixed(2), Paid_Txns:'', First_Paid_Date:'', Last_Paid_Date:''}]
             .concat(rows.map(({Revenue_Paid_Value, ...rest}) => rest));
    }

    async function run(){
      logEl.textContent = '';
      const mondayActiveFile = $('#mondayActive').files[0];
      const mondayOnboardingFile = $('#mondayOnboarding').files[0];
      const stripeFile = $('#stripeCsv').files[0];
      if(!mondayActiveFile || !mondayOnboardingFile || !stripeFile){
        alert('Please select all 3 CSV files.'); return;
      }

      appendLog('Parsing Monday Active...');
      const activeRaw = await csvToObjectsWithHeaderGuess(mondayActiveFile);
      appendLog(`  Active rows: ${activeRaw.length}`);

      appendLog('Parsing Monday Onboarding (new clients)...');
      const onRaw = await csvToObjectsWithHeaderGuess(mondayOnboardingFile);
      appendLog(`  Onboarding rows: ${onRaw.length}`);

      appendLog('Parsing Stripe...');
      const stripeRaw = await csvToObjectsWithHeaderGuess(stripeFile);
      appendLog(`  Stripe rows: ${stripeRaw.length}`);

      // Normalize
      const mondayActive = normalizeMondayActive(activeRaw);
      const mondayOn     = normalizeMondayOnboarding(onRaw);
      const stripeAll    = normalizeStripe(stripeRaw);
      const stripePaid   = stripeAll.filter(r => r.is_paid);
      appendLog(`Stripe paid transactions kept: ${stripePaid.length}`);

      // Build indexes
      const { byStripeId, byEmail, byClientKey } = buildIndexes(mondayActive, mondayOn);
      // Map of ALL known clients (active or onboarding) for totals
      const clientsAll = new Map();
      mondayOn.forEach(r => clientsAll.set(r.client_key, r));
      mondayActive.forEach(r => clientsAll.set(r.client_key, r));
      const onboardingSet = new Set(mondayOn.map(r => r.client_key));

      // Match Stripe → Monday
      const matched = [];
      const unmatched = [];
      for(const t of stripePaid){
        let m = null;
        if(t.customer_id && byStripeId.has(t.customer_id)){
          m = byStripeId.get(t.customer_id);
        } else if(t.customer_email && byEmail.has(t.customer_email)){
          m = byEmail.get(t.customer_email);
        } else if(t.client_key && byClientKey.has(t.client_key)){
          m = byClientKey.get(t.client_key);
        } else {
          const guess = fuzzyGuessClientKey(t.client_key, byClientKey);
          if(guess && byClientKey.has(guess)) m = byClientKey.get(guess);
        }
        if(m){
          matched.push({
            client_key: m.client_key,
            amount: t.amount || 0,
            created_utc: t.created_utc || ''
          });
        } else {
          unmatched.push(t);
        }
      }
      appendLog(`Matched paid Stripe → Monday: ${matched.length}`);
      appendLog(`Unmatched paid Stripe: ${unmatched.length}`);

      // Totals per client (Active or Onboarding)
      const paidTotals = computePaidTotals(clientsAll, matched);

      // Build per-person maps (ACTIVE assignments only; Onboarding has no assignments)
      const fbPer = buildPerPerson(mondayActive, paidTotals, 'Facebook', ROSTERS.FB, onboardingSet);
      const ttPer = buildPerPerson(mondayActive, paidTotals, 'TikTok',   ROSTERS.TT, onboardingSet);
      const ytPer = buildPerPerson(mondayActive, paidTotals, 'YouTube',  ROSTERS.YT, onboardingSet);
      const smmPer= buildPerPerson(mondayActive, paidTotals, 'Posts',    ROSTERS.SMM, onboardingSet);

      // Render
      renderPerPerson(fbPer,  '#fbWrap');
      renderPerPerson(ttPer,  '#ttWrap');
      renderPerPerson(ytPer,  '#ytWrap');
      renderPerPerson(smmPer, '#smmWrap');

      // Onboarding summary (new clients)
      const onbSummary = buildOnboardingSummary(mondayOn, paidTotals);
      renderOnboardingSummary(onbSummary, '#onbWrap');

      // Downloads
      const fbCsv  = flattenPerPersonForCsv(fbPer);
      const ttCsv  = flattenPerPersonForCsv(ttPer);
      const ytCsv  = flattenPerPersonForCsv(ytPer);
      const smmCsv = flattenPerPersonForCsv(smmPer);
      const onbCsv = flattenOnboardingForCsv(onbSummary);

      $('#dlFB').disabled = fbCsv.length === 0;
      $('#dlTT').disabled = ttCsv.length === 0;
      $('#dlYT').disabled = ytCsv.length === 0;
      $('#dlSMM').disabled = smmCsv.length === 0;
      $('#dlOnb').disabled = onbCsv.length === 0;
      $('#dlUnmatched').disabled = unmatched.length === 0;

      $('#dlFB').onclick  = () => downloadCSV('facebook_ams_per_person.csv', fbCsv);
      $('#dlTT').onclick  = () => downloadCSV('tiktok_ams_per_person.csv', ttCsv);
      $('#dlYT').onclick  = () => downloadCSV('youtube_ams_per_person.csv', ytCsv);
      $('#dlSMM').onclick = () => downloadCSV('smm_per_person.csv', smmCsv);
      $('#dlOnb').onclick = () => downloadCSV('onboarding_summary.csv', onbCsv);
      $('#dlUnmatched').onclick = () => downloadCSV('unmatched_paid_stripe_rows.csv', unmatched);

      appendLog('Done.');
    }

    function downloadCSV(filename, rows){
      const csv = Papa.unparse(rows);
      const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    $('#go').addEventListener('click', run);
  </script>
</body>
</html>
